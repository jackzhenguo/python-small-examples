3 交替获得CPU时间片
-------------------

为了更好解释，假定计算机是单核的，尽管对于\ ``cpython``\ ，这个假定有些多余。

开辟3个线程，装到\ ``threads``\ 中:

.. code:: python

    import time
    from datetime import datetime
    import threading


    def print_time():
        for _ in range(5): # 在每个线程中打印5次
            time.sleep(0.1) # 模拟打印前的相关处理逻辑
            print('当前线程%s,打印结束时间为:%s'%(threading.current_thread().getName(),datetime.today()))


    threads = [threading.Thread(name='t%d'%(i,),target=print_time) for i in range(3)]

启动3个线程：

.. code:: python

    [t.start() for t in threads]

打印结果如下，\ ``t0``,\ ``t1``,\ ``t2``\ 三个线程，根据操作系统的调度算法，轮询获得CPU时间片，注意观察，\ ``t2``\ 线程可能被连续调度，从而获得时间片。

.. code:: python

    当前线程t0,打印结束时间为:2020-01-12 02:27:15.705235
    当前线程t1,打印结束时间为:2020-01-12 02:27:15.705402
    当前线程t2,打印结束时间为:2020-01-12 02:27:15.705687
    当前线程t0,打印结束时间为:2020-01-12 02:27:15.805767
    当前线程t1,打印结束时间为:2020-01-12 02:27:15.805886
    当前线程t2,打印结束时间为:2020-01-12 02:27:15.806044
    当前线程t0,打印结束时间为:2020-01-12 02:27:15.906200
    当前线程t2,打印结束时间为:2020-01-12 02:27:15.906320
    当前线程t1,打印结束时间为:2020-01-12 02:27:15.906433
    当前线程t0,打印结束时间为:2020-01-12 02:27:16.006581
    当前线程t1,打印结束时间为:2020-01-12 02:27:16.006766
    当前线程t2,打印结束时间为:2020-01-12 02:27:16.007006
    当前线程t2,打印结束时间为:2020-01-12 02:27:16.107564
    当前线程t0,打印结束时间为:2020-01-12 02:27:16.107290
    当前线程t1,打印结束时间为:2020-01-12 02:27:16.107741

